# 读写分离 {#concept_hbh_m45_j2b .concept}

POLARDB for MySQL集群自带读写分离功能。应用程序只需连接一个集群地址，写请求会自动发往主节点，读请求会自动根据各节点的负载（当前未完成的请求数）发往主节点或只读节点。

## 功能优势 {#section_rfw_ys5_j2b .section}

-   **读一致性** 

    在POLARDB的链路中间层做读写分离的同时，中间层会track各个节点已经apply了的redolog位点即LSN，同时每次更新时会记录此次更新的位点为Session LSN, 当有新请求到来时我们会比较Session LSN 和当前各个节点的LSN，仅将请求发往LSN \>= Session LSN的节点，从而保证了会话一致性；表面上看该方案可能导致主库压力大，但是因为POLARDB是物理复制，速度极快，在上述场景中，当更新完成后，返回客户端结果时复制就同步在进行，而当下一个读请求到来时主从极有可能已经完成，然后大多数应用场景都是读多写少，所以经验证在该机制下即保证了会话一致性，也保证了读写分离负载均衡的效果。

    ![](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/76678/155841788634632_zh-CN.png)

-   **原生支持读写分离，提升性能** 

    如果您在云上通过自己搭建代理层实现读写分离，在数据到达数据库之前需要经历多个组件的语句解析和转发，对响应延迟有较大的影响。而POLARDB读写分离在已有的高安全链路中直接内置，没有任何额外的组件来消耗时间，能够有效降低延迟，提升处理速度。

-   **维护方便** 

    在传统模式下，您需要在应用程序中配置主节点和每个只读节点的连接地址，并且对业务逻辑进行拆分，才能实现将写请求发往主节点而将读请求发往各个节点。

    POLARDB提供集群地址，应用程序连接该地址后即可对主节点和只读节点进行读写操作，读写请求会被自动转发，转发逻辑完全对使用者透明，可降低维护成本。

    同时，您只需添加只读节点的个数，即可不断扩展系统的处理能力，应用程序无需做任何修改。

-   **节点健康检查，提升数据库系统的可用性** 

    读写分离模块自动对集群内的所有节点进行健康检查，当发现某个节点宕机或者延迟超过阈值后，将不再分配读请求给该节点，读写请求在剩余的健康节点间进行分配。以此确保单个只读节点发生故障时，不会影响应用的正常访问。当节点被修复后，POLARDB会自动将该节点纳回请求分配体系内。

-   **免费使用，降低资源及维护成本** 

    免费提供读写分离功能，无需支付任何额外费用。


## 转发逻辑 {#section_mvw_kt5_j2b .section}

-   只发往主节点
    -   所有DML操作（INSERT,UPDATE,DELETE\)
    -   所有DDL操作（建表/库、删表/库、变更表结构、权限等）
    -   所有事务中的请求
    -   用户自定义函数
    -   存储过程
    -   EXECUTE语句
    -   [Multi Statements](https://dev.mysql.com/doc/internals/en/multi-statement.html)
    -   使用到临时表的请求
    -   SELECT last\_insert\_id\(\)
    -   所有对用户变量的查询和更改
    -   SHOW PROCESSLIST
    -   KILL（SQL语句中的KILL，非命令KILL）
-   发往只读节点或主节点
    -   非事务中的读请求
    -   COM\_STMT\_EXECUTE命令
-   总是发往所有节点
    -   所有系统变量的更改
    -   USE命令
    -   COM\_STMT\_PREPARE命令
    -   COM\_CHANGE\_USER/COM\_QUIT/COM\_SET\_OPTION等命令

## 使用限制 {#section_e1j_d55_j2b .section}

不支持[Multi Statements](https://dev.mysql.com/doc/internals/en/multi-statement.html)和存储过程。若执行了Multi Statements，当前连接的后续请求会全部路由到主节点，需断开当前连接并重新连接才能恢复读写分离。

## 申请或修改集群地址 {#section_ksd_h55_j2b .section}

1.  进入[POLARDB控制台](https://polardb.console.aliyun.com/)。
2.  选择地域。
3.  找到目标集群，单击集群名称列的**集群ID**。
4.  在基本信息的访问信息里找到**集群地址（推荐）**。
5.  单击**申请**，在弹出的对话框中单击**确认**，刷新后即可看到集群地址。

    **说明：** 存量集群若未申请**集群读写分离连接地址**的需要手动申请集群地址，新购集群自动开通集群地址。若已有集群地址，请直接查看第6步。

6.  单击**修改**，设置新的集群地址，并单击**提交**。

    ![修改集群地址](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/15443/155841788645064_zh-CN.png)


## FAQs {#section_hrr_m55_j2b .section}

1.  为什么刚插入的语句，立即查的时候查不到？

    答：读写分离的架构下，主从复制会有延迟，但POLARDB支持会话一致性，即同一个会话内保证能读到之前的更新。

2.  为什么只读库没有压力？

    答：默认情况下事务中的请求都会路由到主库，若是用sysbench做压测，0.5版本的sysbench可以加上--oltp-skip-trx=on，1.0版本的sysbench可以加上--skip-trx=on去掉事务，若业务上因为事务较多导致只读库负载过低，可以提交工单开启读写分离下的分布式事务。

3.  为什么某个节点的请求数比别的节点多？

    答：当前是根据负载来分发请求的，负载小的节点接收的请求数会更多。

4.  是否支持0毫秒延迟的读取？

    答：POLARDB集群的主节点和只读节点在正常负载情况下，具有毫秒级的延迟，读写分离连接地址暂时不支持在数据写入后0毫秒的读取。如果要求0毫秒延迟的读取，可使用主地址（动态指向POLARDB主节点）将读写请求发给主节点。

5.  新增的只读节点会自动加入到读写分离吗？

    新增只读节点之后新建的读写分离连接会转发请求到该只读节点。新增只读节点之前建立的读写分离连接不会转发请求到新增的只读节点，需要断开该连接并重新建立连接，例如，重启应用。


